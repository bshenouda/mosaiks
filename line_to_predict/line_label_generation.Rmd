---
title: "Vector label generation"
author: "Benjamin Shenouda, Trinetta Chong, Eugenio Noda, Tamma Carleton"
date: '2022-06-24'
output: rmarkdown::github_document
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Making predictions from vector data

This notebook demonstrates the steps to prepare vector data to make predictions using MOSAIKS features. This notebook makes use of data on roads in the DC area, downloaded from [USGS](https://prd-tnm.s3.amazonaws.com/index.html?prefix=StagedProducts/Tran/Shape/).

## 1. Load shapefile

```{r}

suppressPackageStartupMessages(library(sf))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(mapview))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(rgdal))
suppressPackageStartupMessages(library(glmnet))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(lwgeom))
suppressPackageStartupMessages(library(units))


```

Prepare directories and files

```{r}

input_dir <-  './' #input path to working directory
label_shp_name <-  'TRAN_District_of_Columbia_State_Shape/Shape/Trans_RoadSegment.shp'
target_crs <-  4326 # epsg:4326, the projection of the MOSAIKS grid

label_shp <- st_read(paste0(input_dir, label_shp_name)) # read in shapefile using sf package
label_shp_reprojected <- st_transform(label_shp, crs = target_crs) # if needed, reproject shapefile to epsg:4326
```

Inspect shapefile and data

```{r}
ggplot() +
  geom_sf(data = label_shp_reprojected[,"permanent_"]) +
  labs(title = "DC Permanent Roads")
```

## 2. Create grid

Similar to the process for polygon data, in this step, we create a *grid of polygon cells*, and constrain it by the bounding box of the label data. The specified resolution represents the desired resolution at which predictions are later made.

The grid cells allow us to sum the total length of road segments that fall within each cell, and generate in a next step a tabular dataset of lon/lat coordinates (at the centroid of each cell) with a corresponding value equal to the sum of all road lengths within that cell.

A `target_resolution <- .01` signifies a 0.01 x 0.01 degree latitude-longitude grid, centered at 0.005 degree intervals (0.01 degrees is approximately equivalent to 1.11 km at the equator using an equal angle grid). This resolution is equivalent to that of the MOSAIKS API features. 

In many cases, one can make predictions at a finer resolution than the native resolution of input label data. For example, the native resolution of this label is at the canton administrative level (as seen in the shapefile plot). However, by overlaying our desired grid onto the shapefile and performing a spatial join, we are able to assign label values to each unique cell on a 0.01 x 0.01 degree grid. One should note that increasing the resolution will increase compute time.

```{r}

target_resolution <- .01 # Set target resolution. A resolution of .01 is equal to the .01 x .01 dense grid of the MOSAIKS API.

label_bbox <- st_bbox(label_shp_reprojected, crs = target_crs) # get bounding box of shapefile
#bbox_poly <- bbox_to_poly(label_bbox)
#st_as_sfc(label_bbox)

# Creates grid of at specified resolution starting at the min x and min y coordinates of the label bounding box

grid_cells <- st_make_grid(label_shp_reprojected, 
        cellsize = target_resolution, # cell size intervals for the grid, can be modified for higher or lower resolution -> .01 is equal to the MOSAIKS dense grid
        what = 'polygons', # to render polgyon square cells
        offset = c(round(label_bbox[1], 2), round(label_bbox[2], 2))) # starting at the min x and y of the bbox rounded to 3 digit precision of the MOSAIKS grid

```

Plot grid over vector shapefile

```{r}
# Plot grid over lines
ggplot() +
  geom_sf(data = label_shp_reprojected[,"permanent_"], lwd = 0.09) +
  geom_sf(data = grid_cells, fill = 'transparent', lwd = 0.5) +
  coord_sf(datum = 4326)  +
  labs(x = "lon", y = "lat")

```

## 3. Spatially join the grid with label shapefile and sum lengths of road in each cell (at .01 resolution, this takes a bit of time)

```{r, cache = TRUE}
# rename files for easier reading
line <- label_shp_reprojected
poly <- grid_cells

poly_sf <- st_as_sf(poly) # convert grid cells from sfc to sf object for manipulation

intersection <- st_intersection(line, poly) # find line segments that correspond to each grid cell (takes time)

intersection$len <- st_length(intersection) # calculate length of each line segment in each cell

poly_sf$id <- 1:nrow(poly_sf) # create id for each cell

join <- st_join(poly_sf, intersection) # join the lengths of each line segment to its corresponding polygon

grid_length <- group_by(join, id) %>% #  sum length of all line segments in each cell by cell id
  summarize(length = sum(len))

#grid_length1 <- filter(grid_length, !is.na(length)) # filter out cells without line segments

mutate(grid_length, length = ifelse(is.na(length), 0, length)) # or set length to 0 for cells without lines
```


```{r}
head(grid_length)
grid_length <- drop_units(grid_length) # drop units feature for easy manipulation. Length is in meters

ggplot() +
  geom_sf(data = grid_length, aes(fill = length)) +
  scale_fill_gradientn(colors = sf.colors()) +
  labs(fill = "total road length (m)")
```


```{r}
centroids <- st_centroid(grid_length) # get points at centroid of each grid cell

# Visualize
ggplot() +
  geom_sf(data = grid_length, aes(fill = length)) +
  scale_fill_gradientn(colors = sf.colors()) + 
  geom_sf(data = centroids) +
  labs(fill = "total road length (m)")
```

Extract grid cell values to centroids
```{r}
grid_points <- st_join(centroids, grid_length, join = st_within) # spatial join

# Visualize
ggplot() +
  geom_sf(data = grid_points, aes(color = length.x)) +
  scale_color_gradientn(colors = sf.colors()) +
  labs(color = "total road length (m)")

head(grid_points)
```

############
Plot check

```{r, echo = FALSE, out.width="100%", out.height="100%"}
#plot(label_shp_reprojected[,"ErosPr"], axes = T) # plot shapefile
#plot(label_df[,"ErosPr"], axes = T) #plot newly generated grid data frame

line_plot <- ggplot() +
  geom_sf(data = label_shp_reprojected[,"permanent_"]) +
  ggtitle("Original line data") +
  labs(color = "length(m)")

grid_plot <- ggplot() +
  geom_sf(data = grid_length, aes(fill = length)) +
  scale_fill_gradientn(colors = sf.colors()) +
  ggtitle("Line length aggregrated to grid cells") +
  labs(fill = "length (m)")

points_plot <- ggplot() +
  geom_sf(data = grid_points, aes(color = length.x)) +
  scale_color_gradientn(colors = sf.colors()) +
  ggtitle("Centroids of grid cells") +
  labs(color = "length (m)")

line_plot + grid_plot + points_plot + plot_layout(guides = "collect") & theme(legend.position = 'bottom')
```

## 4. Output the grid to CSV to obtain features from File Query

```{r, echo = FALSE}
# Split sfc point geometry into individual lon/lat values, rounding to precision of MOSAIKS grid for merging
grid_points$lon <- round(st_coordinates(grid_points)[,1], 3)
grid_points$lat <- round(st_coordinates(grid_points)[,2], 3)

grid_points <- grid_points[,c("lon", "lat", "length.x")]

st_write(grid_points, paste0(input_dir, "dc_roads.csv")) # Write to csv - sfc point geomtery is automatically dropped. Results in 3 columns of label value, longitude, and latitude

dc_roads <- read.csv("dc_roads.csv")
```

